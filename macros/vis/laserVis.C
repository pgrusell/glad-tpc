/*

This macro is a different version of readVPadPlane.C, modiffied to
show the results of the laser generation. 

* The "default" use takes thefile generated by the run_laser_gen.C 
macro and show the charge distribution of the pad plane. 

* However, it can still be used to compare different runs of that macro 
to, for instace, study the difference between two magnetic fields or 
different laser... 

*/

////////////////////////////////////////////////////////////////////////
// Global parameters
////////////////////////////////////////////////////////////////////////

TString geoTag = "Prototype";
TString geoPath;
TString GTPCGeoParamsFile;
Double_t fHalfSizeTPC_X;
Double_t fHalfSizeTPC_Y;
Double_t fHalfSizeTPC_Z;
Double_t fSizeOfVirtualPad;
Double_t fMaxDriftTime;
Int_t histoBins;
Int_t histoBins2;
char hname[255];

void initializeGlobals() {
    geoPath = gSystem->Getenv("VMCWORKDIR");
    GTPCGeoParamsFile = geoPath + "/glad-tpc/params/HYDRAprototype_FileSetup.par";
    GTPCGeoParamsFile.ReplaceAll("//", "/");

    FairRuntimeDb* rtdb = FairRuntimeDb::instance();
    R3BGTPCGeoPar* geoPar = (R3BGTPCGeoPar*)rtdb->getContainer("GTPCGeoPar");
    if (!geoPar) {
        cout << "No R3BGTPCGeoPar can be loaded from the rtdb" << endl;
        exit(1);
    }
    R3BGTPCGasPar* gasPar = (R3BGTPCGasPar*)rtdb->getContainer("GTPCGasPar");
    if (!gasPar) {
        cout << "No R3BGTPCGasPar can be loaded from the rtdb" << endl;
        exit(1);
    }

    FairParAsciiFileIo* parIo1 = new FairParAsciiFileIo(); // Ascii file
    parIo1->open(GTPCGeoParamsFile, "in");
    rtdb->setFirstInput(parIo1);
    rtdb->initContainers(0);

    fHalfSizeTPC_X = geoPar->GetActiveRegionx() / 2.; // 50cm in X (row)
    fHalfSizeTPC_Y = geoPar->GetActiveRegiony() / 2.; // 20cm in Y (time)
    fHalfSizeTPC_Z = geoPar->GetActiveRegionz() / 2.; // 100cm in Z (column)
    fSizeOfVirtualPad = geoPar->GetPadSize();         // 1: pads of 1cm^2 , 10: pads of 1mm^2
    fMaxDriftTime = round((geoPar->GetActiveRegiony() / gasPar->GetDriftVelocity()) * pow(10, -3)); // us

    histoBins = 2 * fHalfSizeTPC_X * fSizeOfVirtualPad;
    histoBins2 = 2 * fHalfSizeTPC_Z * fSizeOfVirtualPad;
}


void laserPadPlane(TString inputSimFile, TString title, TString mode)
{
    initializeGlobals();

    TH2D* htrackInPads = 0;
    TH2D* htrackInPads1 = 0;
    TH2D* hdriftTimeInPads = 0;
    TH2D* hdepth1InPads = 0;
    TH2D* hdepth2InPads = 0;
    TH1S** h1_ProjPoint_TimeExample = 0;

    htrackInPads = new TH2D("htrackInPads_"+title,
                            "All tracks in the XZ Pads Plane",
                            histoBins2, 0, histoBins2, histoBins, 0, histoBins); // in [pad number]
    htrackInPads->SetYTitle("X [pad number]");
    htrackInPads->SetXTitle("Z [pad number]");

    
    htrackInPads1 = new TH2D("", "", histoBins, 0, histoBins, histoBins2, 0, histoBins2);


    hdriftTimeInPads = new TH2D("hdriftTimeInPads"+title,
                                "All tracks in the XZ Pads Plane with drift time",
                                histoBins,
                                0,
                                histoBins,
                                histoBins2,
                                0,
                                histoBins2); // in [pad number]
    hdriftTimeInPads->SetYTitle("Z [pad number]");
    hdriftTimeInPads->SetXTitle("X [pad number]");

    hdepth1InPads = new TH2D("hdepth1InPads"+title,
                             "track In the Drift-Z Pads Plane",
                             histoBins,
                             0,
                             fMaxDriftTime,
                             histoBins2,
                             0,
                             histoBins2);
    hdepth1InPads->SetYTitle("Z [pad number]");
    hdepth1InPads->SetXTitle("(drift) time [us]");

    hdepth2InPads = new TH2D("hdepth2InPads"+title,
                             "track In the Drift-X Pads Plane",
                             histoBins,
                             0,
                             fMaxDriftTime,
                             histoBins,
                             0,
                             histoBins);
    hdepth2InPads->SetYTitle("X [pad number]");
    hdepth2InPads->SetXTitle("(drift) time [us]");

    ////////////////////////////////////////////////////////////////////////
    // EVENT ACCESS
    ////////////////////////////////////////////////////////////////////////

    // File access
    TFile* simFile = TFile::Open(inputSimFile, "READ");
    TTree* TEvt = (TTree*)simFile->Get("evt");
    Int_t nevents = TEvt->GetEntries();

    // Projection Point Definition
    TClonesArray* gtpcProjPointCA;
    R3BGTPCProjPoint* ppoint = new R3BGTPCProjPoint;
    gtpcProjPointCA = new TClonesArray("R3BGTPCProjPoint", 5);
    TBranch* branchGTPCProjPoint = TEvt->GetBranch("GTPCProjPoint");
    branchGTPCProjPoint->SetAddress(&gtpcProjPointCA);

    // Event 0 analysis
    Int_t padsPerEvent = 0;
    Int_t nb = 0;
    Int_t beamPadsWithSignalPerEvent, productPadsWithSignalPerEvent;
    Double_t tPad;
    Int_t xPad, zPad, yPad;
    Int_t numberOfTimeHistos = 0;

    gtpcProjPointCA->Clear();
    nb += TEvt->GetEvent(0);
    padsPerEvent = gtpcProjPointCA->GetEntries();

    if (padsPerEvent > 0)
    {
        h1_ProjPoint_TimeExample = new TH1S*[padsPerEvent];
        for (Int_t h = 0; h < padsPerEvent; h++)
        {
            ppoint = (R3BGTPCProjPoint*)gtpcProjPointCA->At(h);

            tPad = ((TH1S*)(ppoint->GetTimeDistribution()))->GetMean();

            if (ppoint->GetVirtualPadID() == -1){continue;}

            htrackInPads1->GetBinXYZ(ppoint->GetVirtualPadID(), xPad, zPad, yPad);
            xPad--;
            zPad--;

            htrackInPads->Fill(zPad, xPad, ppoint->GetCharge());
            hdriftTimeInPads->Fill(xPad, zPad, tPad);
            hdepth1InPads->Fill(tPad, zPad, ppoint->GetCharge());
            hdepth2InPads->Fill(tPad, xPad, ppoint->GetCharge());

            sprintf(hname, "pad %i", ppoint->GetVirtualPadID());
            h1_ProjPoint_TimeExample[h] = (TH1S*)((ppoint->GetTimeDistribution()))->Clone(hname);
        }

        numberOfTimeHistos = padsPerEvent;
    }

    ////////////////////////////////////////////////////////////////////////
    // RESULTS
    ////////////////////////////////////////////////////////////////////////

    auto *file = new TFile("laser_results.root", mode);
    gROOT->SetStyle("Default");
    //htrackInPads->Draw("zcol");
    htrackInPads->Write();

    file->Close();


}




void laserVis(TString gladFieldSource = "../proj/Prototype/laser_gen_gladField.root", TString constFieldSource = "no_init")
{

    initializeGlobals();

    // Save the pad plane projections using the former function
    laserPadPlane(gladFieldSource, "gladField", "RECREATE");
    laserPadPlane("../proj/Prototype/laser_gen_gladField_mid.root", "gladField_mid", "UPDATE");
    if (constFieldSource != "no_init"){laserPadPlane(constFieldSource, "constField", "UPDATE");}
    
    // Get both histograms
    auto *f = new TFile("laser_results.root", "read");
    auto *histo1 = (TH2S*)f->Get("htrackInPads_constField"); 
    auto *histo2 = (TH2S*)f->Get("htrackInPads_gladField"); 
    auto *histo3 = (TH2S*)f->Get("htrackInPads_gladField_mid"); 

    
    if (histo1 == NULL)
    {
        Int_t kScale = 10;
        auto *c = new TCanvas("", "", kScale*128, kScale*44);
        c->cd();
        gStyle->SetPalette(kViridis);
        histo2->Draw("colz");
        

    }
    else
    {
        
        // Get the projections
        auto *projConst = histo1->ProfileY();
        auto *projGlad = histo2->ProfileY();
        auto *projGlad_mid = histo3->ProfileY();

        // Draw and compare both results
        auto *c = new TCanvas();
        projConst->Draw();
        projGlad->SetLineColor(kRed);
        projGlad->Draw("same");
        projGlad_mid->SetLineColor(kGreen);
        projGlad_mid->Draw("same");
        




       
    }




}